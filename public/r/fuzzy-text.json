{
  "name": "fuzzy-text",
  "description": "Retro CRT television effect with static noise, scanlines, and progressive text reveal.",
  "type": "registry:ui",
  "dependencies": [
    "framer-motion",
    "react"
  ],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:ui",
      "content": "'use client';\n\nimport { useEffect, useRef, useState, useCallback, useMemo } from 'react';\nimport { motion, useInView } from 'framer-motion';\n\ninterface FuzzyTextProps {\n  text: string;\n  className?: string;\n  fontSize?: string;\n  noiseIntensity?: number;\n  enableHover?: boolean;\n  baseColor?: string;\n  glowColor?: string;\n  speed?: number;\n}\n\nexport const FuzzyText = ({\n  text,\n  className = '',\n  fontSize = '4rem',\n  noiseIntensity = 1,\n  enableHover = true,\n  baseColor = '#fff',\n  glowColor = '#fff',\n  speed = 50,\n}: Readonly<FuzzyTextProps>) => {\n  const containerRef = useRef<HTMLSpanElement>(null);\n  const [isHovered, setIsHovered] = useState(false);\n  const [displayText, setDisplayText] = useState(text);\n  const animationRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Noise characters for the fuzzy effect\n  const noiseChars = useMemo(\n    () => '!<>-_\\\\/[]{}â€”=+*^?#_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n    [],\n  );\n\n  const getRandomChar = useCallback(() => {\n    return noiseChars[Math.floor(Math.random() * noiseChars.length)];\n  }, [noiseChars]);\n\n  // Apply noise to text when not hovered\n  useEffect(() => {\n    if (!enableHover) {\n      // Always show noise when hover is disabled\n      animationRef.current = setInterval(() => {\n        const noisyText = text\n          .split('')\n          .map((char) => {\n            if (char === ' ') return char;\n            return Math.random() < noiseIntensity * 0.3 ? getRandomChar() : char;\n          })\n          .join('');\n        setDisplayText(noisyText);\n      }, speed);\n\n      return () => {\n        if (animationRef.current) clearInterval(animationRef.current);\n      };\n    }\n\n    if (!isHovered) {\n      // Apply noise effect when not hovered\n      animationRef.current = setInterval(() => {\n        const noisyText = text\n          .split('')\n          .map((char) => {\n            if (char === ' ') return char;\n            return Math.random() < noiseIntensity * 0.3 ? getRandomChar() : char;\n          })\n          .join('');\n        setDisplayText(noisyText);\n      }, speed);\n    } else {\n      // Show clear text when hovered\n      setDisplayText(text);\n      if (animationRef.current) {\n        clearInterval(animationRef.current);\n      }\n    }\n\n    return () => {\n      if (animationRef.current) clearInterval(animationRef.current);\n    };\n  }, [isHovered, text, noiseIntensity, enableHover, getRandomChar, speed]);\n\n  const uniqueId = useMemo(\n    () => `fuzzy-${Math.random().toString(36).substr(2, 9)}`,\n    [],\n  );\n\n  return (\n    <span\n      ref={containerRef}\n      className={`relative inline-block cursor-pointer ${className}`}\n      onMouseEnter={() => setIsHovered(true)}\n      onMouseLeave={() => setIsHovered(false)}\n      style={{\n        fontSize,\n        fontWeight: 'bold',\n      }}\n    >\n      {/* SVG Filter for noise effect */}\n      <svg width=\"0\" height=\"0\" className=\"absolute\">\n        <defs>\n          <filter id={`${uniqueId}-noise`}>\n            <feTurbulence\n              type=\"fractalNoise\"\n              baseFrequency={isHovered ? '0' : '0.8'}\n              numOctaves=\"4\"\n              seed={Math.random() * 100}\n              stitchTiles=\"stitch\"\n              result=\"noise\"\n            />\n            <feDisplacementMap\n              in=\"SourceGraphic\"\n              in2=\"noise\"\n              scale={isHovered ? 0 : 2 * noiseIntensity}\n              xChannelSelector=\"R\"\n              yChannelSelector=\"G\"\n            />\n          </filter>\n        </defs>\n      </svg>\n\n      {/* Main text with noise effect */}\n      <motion.span\n        className=\"relative inline-block\"\n        style={{\n          color: baseColor,\n          filter: `url(#${uniqueId}-noise)`,\n          textShadow: `\n            0 0 ${isHovered ? 20 : 5}px ${glowColor},\n            0 0 ${isHovered ? 40 : 10}px ${glowColor},\n            0 0 ${isHovered ? 60 : 15}px ${glowColor}\n          `,\n        }}\n        animate={{\n          x: isHovered ? 0 : [0, -1, 1, -1, 0],\n          y: isHovered ? 0 : [0, 1, -1, 1, 0],\n        }}\n        transition={{\n          duration: 0.1,\n          repeat: isHovered ? 0 : Infinity,\n          repeatType: 'loop',\n        }}\n      >\n        {displayText}\n      </motion.span>\n\n      {/* Chromatic aberration layers */}\n      {!isHovered && (\n        <>\n          {/* Red channel offset */}\n          <motion.span\n            className=\"pointer-events-none absolute left-0 top-0\"\n            style={{\n              color: 'transparent',\n              textShadow: `0 0 2px rgba(255, 0, 0, ${0.4 * noiseIntensity})`,\n              mixBlendMode: 'screen',\n            }}\n            animate={{\n              x: [-2, 2, -2],\n              opacity: [0.5, 0.8, 0.5],\n            }}\n            transition={{\n              duration: 0.15,\n              repeat: Infinity,\n              repeatType: 'reverse',\n            }}\n          >\n            {displayText}\n          </motion.span>\n\n          {/* Blue channel offset */}\n          <motion.span\n            className=\"pointer-events-none absolute left-0 top-0\"\n            style={{\n              color: 'transparent',\n              textShadow: `0 0 2px rgba(0, 100, 255, ${0.4 * noiseIntensity})`,\n              mixBlendMode: 'screen',\n            }}\n            animate={{\n              x: [2, -2, 2],\n              opacity: [0.5, 0.8, 0.5],\n            }}\n            transition={{\n              duration: 0.15,\n              repeat: Infinity,\n              repeatType: 'reverse',\n            }}\n          >\n            {displayText}\n          </motion.span>\n        </>\n      )}\n\n      {/* Scanlines */}\n      <motion.span\n        className=\"pointer-events-none absolute inset-0 z-10\"\n        style={{\n          background: `repeating-linear-gradient(\n            0deg,\n            transparent,\n            transparent 2px,\n            rgba(0, 0, 0, ${isHovered ? 0.05 : 0.15}) 2px,\n            rgba(0, 0, 0, ${isHovered ? 0.05 : 0.15}) 4px\n          )`,\n        }}\n        animate={{\n          backgroundPosition: ['0 0', '0 4px'],\n        }}\n        transition={{\n          duration: 0.5,\n          repeat: Infinity,\n          ease: 'linear',\n        }}\n      />\n\n      {/* Occasional glitch flicker */}\n      <motion.span\n        className=\"pointer-events-none absolute inset-0\"\n        style={{\n          background: 'rgba(255, 255, 255, 0.03)',\n        }}\n        animate={{\n          opacity: isHovered ? 0 : [0, 1, 0, 0, 1, 0],\n        }}\n        transition={{\n          duration: 0.5,\n          repeat: Infinity,\n          times: [0, 0.1, 0.12, 0.8, 0.82, 1],\n        }}\n      />\n    </span>\n  );\n};\n\nexport default FuzzyText;\n",
      "path": "/components/ui/fuzzy-text.tsx",
      "target": "components/ui/fuzzy-text.tsx"
    }
  ],
  "categories": [
    "text-animation"
  ]
}