{
  "name": "glitch-text",
  "description": "Cyberpunk-style glitch effect with RGB color splitting, position jittering, and scanlines.",
  "type": "registry:ui",
  "dependencies": [
    "framer-motion",
    "react"
  ],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:ui",
      "content": "'use client';\r\n\r\nimport { useEffect, useRef, useState, useCallback } from 'react';\r\nimport { motion, useInView } from 'framer-motion';\r\n\r\ninterface GlitchTextProps {\r\n  text: string;\r\n  className?: string;\r\n  intensity?: number;\r\n  colors?: [string, string];\r\n  duration?: number;\r\n  glitchInterval?: number;\r\n  trigger?: 'mount' | 'hover' | 'inView' | 'continuous';\r\n}\r\n\r\nexport const GlitchText = ({\r\n  text,\r\n  className = '',\r\n  intensity = 5,\r\n  colors = ['#ff0000', '#00ffff'],\r\n  duration = 0.2,\r\n  glitchInterval = 3000,\r\n  trigger = 'continuous',\r\n}: Readonly<GlitchTextProps>) => {\r\n  const containerRef = useRef<HTMLSpanElement>(null);\r\n  const isInView = useInView(containerRef, { once: false, amount: 0.5 });\r\n  const [isHovering, setIsHovering] = useState(false);\r\n  const [isGlitching, setIsGlitching] = useState(false);\r\n  const glitchTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n  const shouldAnimate = useCallback(() => {\r\n    switch (trigger) {\r\n      case 'continuous':\r\n        return true;\r\n      case 'mount':\r\n        return true;\r\n      case 'inView':\r\n        return isInView;\r\n      case 'hover':\r\n        return isHovering;\r\n      default:\r\n        return false;\r\n    }\r\n  }, [trigger, isInView, isHovering]);\r\n\r\n  useEffect(() => {\r\n    if (!shouldAnimate()) {\r\n      setIsGlitching(false);\r\n      return;\r\n    }\r\n\r\n    const triggerGlitch = () => {\r\n      setIsGlitching(true);\r\n      setTimeout(() => setIsGlitching(false), duration * 1000);\r\n    };\r\n\r\n    // Initial glitch\r\n    triggerGlitch();\r\n\r\n    // Set up interval for continuous glitching\r\n    if (trigger === 'continuous' || trigger === 'inView') {\r\n      glitchTimeoutRef.current = setInterval(triggerGlitch, glitchInterval);\r\n    }\r\n\r\n    return () => {\r\n      if (glitchTimeoutRef.current) {\r\n        clearInterval(glitchTimeoutRef.current);\r\n      }\r\n    };\r\n  }, [shouldAnimate, duration, glitchInterval, trigger]);\r\n\r\n  const glitchAnimation = {\r\n    x: isGlitching\r\n      ? [0, -intensity, intensity, -intensity / 2, intensity / 2, 0]\r\n      : 0,\r\n    y: isGlitching ? [0, intensity / 2, -intensity / 2, 0] : 0,\r\n  };\r\n\r\n  return (\r\n    <motion.span\r\n      ref={containerRef}\r\n      className={`relative inline-block ${className}`}\r\n      onMouseEnter={() => setIsHovering(true)}\r\n      onMouseLeave={() => setIsHovering(false)}\r\n      style={{ position: 'relative' }}\r\n    >\r\n      {/* Red/Cyan offset layers for RGB split effect */}\r\n      <motion.span\r\n        className=\"pointer-events-none absolute inset-0\"\r\n        style={{\r\n          color: colors[0],\r\n          clipPath: isGlitching\r\n            ? 'polygon(0 0, 100% 0, 100% 45%, 0 45%)'\r\n            : 'none',\r\n          opacity: isGlitching ? 0.8 : 0,\r\n        }}\r\n        animate={{\r\n          x: isGlitching ? [-intensity, intensity, -intensity / 2] : 0,\r\n        }}\r\n        transition={{ duration: duration / 3, ease: 'linear' }}\r\n      >\r\n        {text}\r\n      </motion.span>\r\n\r\n      <motion.span\r\n        className=\"pointer-events-none absolute inset-0\"\r\n        style={{\r\n          color: colors[1],\r\n          clipPath: isGlitching\r\n            ? 'polygon(0 55%, 100% 55%, 100% 100%, 0 100%)'\r\n            : 'none',\r\n          opacity: isGlitching ? 0.8 : 0,\r\n        }}\r\n        animate={{\r\n          x: isGlitching ? [intensity, -intensity, intensity / 2] : 0,\r\n        }}\r\n        transition={{ duration: duration / 3, ease: 'linear' }}\r\n      >\r\n        {text}\r\n      </motion.span>\r\n\r\n      {/* Main text with position glitch */}\r\n      <motion.span\r\n        className=\"relative z-10\"\r\n        animate={glitchAnimation}\r\n        transition={{\r\n          duration: duration,\r\n          ease: 'linear',\r\n          times: [0, 0.2, 0.4, 0.6, 0.8, 1],\r\n        }}\r\n        style={{\r\n          textShadow: isGlitching\r\n            ? `${intensity / 2}px 0 ${colors[0]}, ${-intensity / 2}px 0 ${colors[1]}`\r\n            : 'none',\r\n        }}\r\n      >\r\n        {text}\r\n      </motion.span>\r\n\r\n      {/* Scanline effect */}\r\n      {isGlitching && (\r\n        <motion.span\r\n          className=\"pointer-events-none absolute inset-0 z-20\"\r\n          style={{\r\n            background: `repeating-linear-gradient(\r\n              0deg,\r\n              transparent,\r\n              transparent 2px,\r\n              rgba(0, 0, 0, 0.1) 2px,\r\n              rgba(0, 0, 0, 0.1) 4px\r\n            )`,\r\n          }}\r\n          initial={{ opacity: 0 }}\r\n          animate={{ opacity: [0, 1, 0] }}\r\n          transition={{ duration: duration }}\r\n        />\r\n      )}\r\n    </motion.span>\r\n  );\r\n};\r\n\r\nexport default GlitchText;\r\n",
      "path": "/components/ui/glitch-text.tsx",
      "target": "components/ui/glitch-text.tsx"
    }
  ],
  "categories": [
    "text-animation"
  ]
}