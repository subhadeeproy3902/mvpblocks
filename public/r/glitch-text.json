{
  "name": "glitch-text",
  "description": "Cyberpunk-style glitch effect with RGB color splitting, position jittering, and scanlines.",
  "type": "registry:ui",
  "dependencies": [
    "framer-motion",
    "react"
  ],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:ui",
      "content": "'use client';\n\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { motion, useInView } from 'framer-motion';\n\ninterface GlitchTextProps {\n  text: string;\n  className?: string;\n  intensity?: number;\n  colors?: [string, string];\n  duration?: number;\n  glitchInterval?: number;\n  trigger?: 'mount' | 'hover' | 'inView' | 'continuous';\n}\n\nexport const GlitchText = ({\n  text,\n  className = '',\n  intensity = 5,\n  colors = ['#ff0000', '#00ffff'],\n  duration = 0.2,\n  glitchInterval = 3000,\n  trigger = 'continuous',\n}: Readonly<GlitchTextProps>) => {\n  const containerRef = useRef<HTMLSpanElement>(null);\n  const isInView = useInView(containerRef, { once: false, amount: 0.5 });\n  const [isHovering, setIsHovering] = useState(false);\n  const [isGlitching, setIsGlitching] = useState(false);\n  const glitchTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  const shouldAnimate = useCallback(() => {\n    switch (trigger) {\n      case 'continuous':\n        return true;\n      case 'mount':\n        return true;\n      case 'inView':\n        return isInView;\n      case 'hover':\n        return isHovering;\n      default:\n        return false;\n    }\n  }, [trigger, isInView, isHovering]);\n\n  useEffect(() => {\n    if (!shouldAnimate()) {\n      setIsGlitching(false);\n      return;\n    }\n\n    const triggerGlitch = () => {\n      setIsGlitching(true);\n      setTimeout(() => setIsGlitching(false), duration * 1000);\n    };\n\n    // Initial glitch\n    triggerGlitch();\n\n    // Set up interval for continuous glitching\n    if (trigger === 'continuous' || trigger === 'inView') {\n      glitchTimeoutRef.current = setInterval(triggerGlitch, glitchInterval);\n    }\n\n    return () => {\n      if (glitchTimeoutRef.current) {\n        clearInterval(glitchTimeoutRef.current);\n      }\n    };\n  }, [shouldAnimate, duration, glitchInterval, trigger]);\n\n  const glitchAnimation = {\n    x: isGlitching\n      ? [0, -intensity, intensity, -intensity / 2, intensity / 2, 0]\n      : 0,\n    y: isGlitching ? [0, intensity / 2, -intensity / 2, 0] : 0,\n  };\n\n  return (\n    <motion.span\n      ref={containerRef}\n      className={`relative inline-block ${className}`}\n      onMouseEnter={() => setIsHovering(true)}\n      onMouseLeave={() => setIsHovering(false)}\n      style={{ position: 'relative' }}\n    >\n      {/* Red/Cyan offset layers for RGB split effect */}\n      <motion.span\n        className=\"pointer-events-none absolute inset-0\"\n        style={{\n          color: colors[0],\n          clipPath: isGlitching\n            ? 'polygon(0 0, 100% 0, 100% 45%, 0 45%)'\n            : 'none',\n          opacity: isGlitching ? 0.8 : 0,\n        }}\n        animate={{\n          x: isGlitching ? [-intensity, intensity, -intensity / 2] : 0,\n        }}\n        transition={{ duration: duration / 3, ease: 'linear' }}\n      >\n        {text}\n      </motion.span>\n\n      <motion.span\n        className=\"pointer-events-none absolute inset-0\"\n        style={{\n          color: colors[1],\n          clipPath: isGlitching\n            ? 'polygon(0 55%, 100% 55%, 100% 100%, 0 100%)'\n            : 'none',\n          opacity: isGlitching ? 0.8 : 0,\n        }}\n        animate={{\n          x: isGlitching ? [intensity, -intensity, intensity / 2] : 0,\n        }}\n        transition={{ duration: duration / 3, ease: 'linear' }}\n      >\n        {text}\n      </motion.span>\n\n      {/* Main text with position glitch */}\n      <motion.span\n        className=\"relative z-10\"\n        animate={glitchAnimation}\n        transition={{\n          duration: duration,\n          ease: 'linear',\n          times: [0, 0.2, 0.4, 0.6, 0.8, 1],\n        }}\n        style={{\n          textShadow: isGlitching\n            ? `${intensity / 2}px 0 ${colors[0]}, ${-intensity / 2}px 0 ${colors[1]}`\n            : 'none',\n        }}\n      >\n        {text}\n      </motion.span>\n\n      {/* Scanline effect */}\n      {isGlitching && (\n        <motion.span\n          className=\"pointer-events-none absolute inset-0 z-20\"\n          style={{\n            background: `repeating-linear-gradient(\n              0deg,\n              transparent,\n              transparent 2px,\n              rgba(0, 0, 0, 0.1) 2px,\n              rgba(0, 0, 0, 0.1) 4px\n            )`,\n          }}\n          initial={{ opacity: 0 }}\n          animate={{ opacity: [0, 1, 0] }}\n          transition={{ duration: duration }}\n        />\n      )}\n    </motion.span>\n  );\n};\n\nexport default GlitchText;\n",
      "path": "/components/ui/glitch-text.tsx",
      "target": "components/ui/glitch-text.tsx"
    }
  ],
  "categories": [
    "text-animation"
  ]
}