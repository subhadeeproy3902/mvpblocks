{
  "name": "shuffle-text",
  "description": "A text scramble/shuffle animation that reveals text with a decode effect. Supports mount, hover, and scroll-based triggers.",
  "type": "registry:ui",
  "dependencies": [
    "framer-motion",
    "react"
  ],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:ui",
      "content": "'use client';\r\n\r\nimport { useCallback, useEffect, useRef, useState } from 'react';\r\nimport { motion, useInView, useScroll, useTransform } from 'framer-motion';\r\n\r\ninterface ShuffleTextProps {\r\n  text: string;\r\n  trigger?: 'hover' | 'mount' | 'scroll';\r\n  className?: string;\r\n  characterSet?: string;\r\n  scrambleSpeed?: number;\r\n  revealDelay?: number;\r\n  onComplete?: () => void;\r\n}\r\n\r\nconst DEFAULT_CHARACTER_SET =\r\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';\r\n\r\nexport const ShuffleText = ({\r\n  text,\r\n  trigger = 'mount',\r\n  className = '',\r\n  characterSet = DEFAULT_CHARACTER_SET,\r\n  scrambleSpeed = 50,\r\n  revealDelay = 100,\r\n  onComplete,\r\n}: Readonly<ShuffleTextProps>) => {\r\n  const [displayText, setDisplayText] = useState<string>('');\r\n  const [isAnimating, setIsAnimating] = useState(false);\r\n  const [hasAnimated, setHasAnimated] = useState(false);\r\n  const [scrollRevealedCount, setScrollRevealedCount] = useState(0);\r\n  const containerRef = useRef<HTMLSpanElement>(null);\r\n  const scrambleIntervalRef = useRef<NodeJS.Timeout | null>(null);\r\n  const revealTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n  // Scroll-based animation\r\n  const { scrollYProgress } = useScroll({\r\n    target: containerRef,\r\n    offset: ['start 0.9', 'start 0.3'],\r\n  });\r\n\r\n  const getRandomChar = useCallback(() => {\r\n    return characterSet[Math.floor(Math.random() * characterSet.length)];\r\n  }, [characterSet]);\r\n\r\n  const getScrambledText = useCallback(\r\n    (revealed: number) => {\r\n      return text\r\n        .split('')\r\n        .map((char, index) => {\r\n          if (char === ' ') return ' ';\r\n          if (index < revealed) return char;\r\n          return getRandomChar();\r\n        })\r\n        .join('');\r\n    },\r\n    [text, getRandomChar],\r\n  );\r\n\r\n  // Scroll-based reveal effect\r\n  useEffect(() => {\r\n    if (trigger !== 'scroll') return;\r\n\r\n    let scrambleInterval: NodeJS.Timeout | null = null;\r\n\r\n    // Start scramble effect\r\n    scrambleInterval = setInterval(() => {\r\n      setDisplayText(getScrambledText(scrollRevealedCount));\r\n    }, scrambleSpeed);\r\n\r\n    const unsubscribe = scrollYProgress.on('change', (progress) => {\r\n      const totalChars = text.length;\r\n      const newRevealedCount = Math.floor(progress * totalChars);\r\n      setScrollRevealedCount(newRevealedCount);\r\n\r\n      if (progress >= 1 && !hasAnimated) {\r\n        setHasAnimated(true);\r\n        setDisplayText(text);\r\n        onComplete?.();\r\n      }\r\n    });\r\n\r\n    return () => {\r\n      unsubscribe();\r\n      if (scrambleInterval) clearInterval(scrambleInterval);\r\n    };\r\n  }, [\r\n    trigger,\r\n    scrollYProgress,\r\n    text,\r\n    scrambleSpeed,\r\n    getScrambledText,\r\n    scrollRevealedCount,\r\n    hasAnimated,\r\n    onComplete,\r\n  ]);\r\n\r\n  // Mount/Hover animation\r\n  const animate = useCallback(() => {\r\n    if (isAnimating || trigger === 'scroll') return;\r\n\r\n    setIsAnimating(true);\r\n    setHasAnimated(true);\r\n\r\n    let currentRevealed = 0;\r\n\r\n    // Scramble effect - continuously randomize unrevealed characters\r\n    scrambleIntervalRef.current = setInterval(() => {\r\n      setDisplayText(getScrambledText(currentRevealed));\r\n    }, scrambleSpeed);\r\n\r\n    // Reveal characters one by one\r\n    const revealNext = () => {\r\n      // Skip spaces\r\n      while (currentRevealed < text.length && text[currentRevealed] === ' ') {\r\n        currentRevealed++;\r\n      }\r\n\r\n      if (currentRevealed < text.length) {\r\n        currentRevealed++;\r\n        setDisplayText(getScrambledText(currentRevealed));\r\n\r\n        revealTimeoutRef.current = setTimeout(revealNext, revealDelay);\r\n      } else {\r\n        // Animation complete\r\n        if (scrambleIntervalRef.current) {\r\n          clearInterval(scrambleIntervalRef.current);\r\n        }\r\n        setDisplayText(text);\r\n        setIsAnimating(false);\r\n        onComplete?.();\r\n      }\r\n    };\r\n\r\n    // Start with scrambled text, then begin revealing\r\n    setDisplayText(getScrambledText(0));\r\n    revealTimeoutRef.current = setTimeout(revealNext, revealDelay);\r\n  }, [\r\n    text,\r\n    scrambleSpeed,\r\n    revealDelay,\r\n    isAnimating,\r\n    trigger,\r\n    getScrambledText,\r\n    onComplete,\r\n  ]);\r\n\r\n  const reset = useCallback(() => {\r\n    if (scrambleIntervalRef.current) {\r\n      clearInterval(scrambleIntervalRef.current);\r\n    }\r\n    if (revealTimeoutRef.current) {\r\n      clearTimeout(revealTimeoutRef.current);\r\n    }\r\n    setDisplayText(text);\r\n    setIsAnimating(false);\r\n  }, [text]);\r\n\r\n  // Mount trigger\r\n  useEffect(() => {\r\n    if (trigger === 'mount' && !hasAnimated) {\r\n      animate();\r\n    }\r\n  }, [trigger, hasAnimated, animate]);\r\n\r\n  // Initialize display text for hover/scroll\r\n  useEffect(() => {\r\n    if (trigger === 'hover') {\r\n      setDisplayText(text);\r\n    }\r\n    if (trigger === 'scroll') {\r\n      setDisplayText(getScrambledText(0));\r\n    }\r\n  }, [text, trigger, getScrambledText]);\r\n\r\n  // Cleanup\r\n  useEffect(() => {\r\n    return () => {\r\n      if (scrambleIntervalRef.current) {\r\n        clearInterval(scrambleIntervalRef.current);\r\n      }\r\n      if (revealTimeoutRef.current) {\r\n        clearTimeout(revealTimeoutRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const handleMouseEnter = () => {\r\n    if (trigger === 'hover') {\r\n      setHasAnimated(false);\r\n      animate();\r\n    }\r\n  };\r\n\r\n  const handleMouseLeave = () => {\r\n    if (trigger === 'hover') {\r\n      reset();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <motion.span\r\n      ref={containerRef}\r\n      className={`inline-block ${className}`}\r\n      onMouseEnter={handleMouseEnter}\r\n      onMouseLeave={handleMouseLeave}\r\n      initial={{ opacity: 0 }}\r\n      animate={{ opacity: 1 }}\r\n      transition={{ duration: 0.2 }}\r\n    >\r\n      {displayText.split('').map((char, index) => (\r\n        <motion.span\r\n          key={`${index}-${char}`}\r\n          className=\"inline-block\"\r\n          style={{\r\n            whiteSpace: char === ' ' ? 'pre' : 'normal',\r\n          }}\r\n        >\r\n          {char}\r\n        </motion.span>\r\n      ))}\r\n    </motion.span>\r\n  );\r\n};\r\n\r\nexport default ShuffleText;\r\n",
      "path": "/components/ui/shuffle-text.tsx",
      "target": "components/ui/shuffle-text.tsx"
    }
  ],
  "categories": [
    "text-animation"
  ]
}