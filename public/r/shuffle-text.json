{
  "name": "shuffle-text",
  "description": "A text scramble/shuffle animation that reveals text with a decode effect. Supports mount, hover, and scroll-based triggers.",
  "type": "registry:ui",
  "dependencies": [
    "framer-motion",
    "react"
  ],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:ui",
      "content": "'use client';\n\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport { motion, useInView, useScroll, useTransform } from 'framer-motion';\n\ninterface ShuffleTextProps {\n  text: string;\n  trigger?: 'hover' | 'mount' | 'scroll';\n  className?: string;\n  characterSet?: string;\n  scrambleSpeed?: number;\n  revealDelay?: number;\n  onComplete?: () => void;\n}\n\nconst DEFAULT_CHARACTER_SET =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*';\n\nexport const ShuffleText = ({\n  text,\n  trigger = 'mount',\n  className = '',\n  characterSet = DEFAULT_CHARACTER_SET,\n  scrambleSpeed = 50,\n  revealDelay = 100,\n  onComplete,\n}: Readonly<ShuffleTextProps>) => {\n  const [displayText, setDisplayText] = useState<string>('');\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [hasAnimated, setHasAnimated] = useState(false);\n  const [scrollRevealedCount, setScrollRevealedCount] = useState(0);\n  const containerRef = useRef<HTMLSpanElement>(null);\n  const scrambleIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const revealTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Scroll-based animation\n  const { scrollYProgress } = useScroll({\n    target: containerRef,\n    offset: ['start 0.9', 'start 0.3'],\n  });\n\n  const getRandomChar = useCallback(() => {\n    return characterSet[Math.floor(Math.random() * characterSet.length)];\n  }, [characterSet]);\n\n  const getScrambledText = useCallback(\n    (revealed: number) => {\n      return text\n        .split('')\n        .map((char, index) => {\n          if (char === ' ') return ' ';\n          if (index < revealed) return char;\n          return getRandomChar();\n        })\n        .join('');\n    },\n    [text, getRandomChar],\n  );\n\n  // Scroll-based reveal effect\n  useEffect(() => {\n    if (trigger !== 'scroll') return;\n\n    let scrambleInterval: NodeJS.Timeout | null = null;\n\n    // Start scramble effect\n    scrambleInterval = setInterval(() => {\n      setDisplayText(getScrambledText(scrollRevealedCount));\n    }, scrambleSpeed);\n\n    const unsubscribe = scrollYProgress.on('change', (progress) => {\n      const totalChars = text.length;\n      const newRevealedCount = Math.floor(progress * totalChars);\n      setScrollRevealedCount(newRevealedCount);\n\n      if (progress >= 1 && !hasAnimated) {\n        setHasAnimated(true);\n        setDisplayText(text);\n        onComplete?.();\n      }\n    });\n\n    return () => {\n      unsubscribe();\n      if (scrambleInterval) clearInterval(scrambleInterval);\n    };\n  }, [\n    trigger,\n    scrollYProgress,\n    text,\n    scrambleSpeed,\n    getScrambledText,\n    scrollRevealedCount,\n    hasAnimated,\n    onComplete,\n  ]);\n\n  // Mount/Hover animation\n  const animate = useCallback(() => {\n    if (isAnimating || trigger === 'scroll') return;\n\n    setIsAnimating(true);\n    setHasAnimated(true);\n\n    let currentRevealed = 0;\n\n    // Scramble effect - continuously randomize unrevealed characters\n    scrambleIntervalRef.current = setInterval(() => {\n      setDisplayText(getScrambledText(currentRevealed));\n    }, scrambleSpeed);\n\n    // Reveal characters one by one\n    const revealNext = () => {\n      // Skip spaces\n      while (currentRevealed < text.length && text[currentRevealed] === ' ') {\n        currentRevealed++;\n      }\n\n      if (currentRevealed < text.length) {\n        currentRevealed++;\n        setDisplayText(getScrambledText(currentRevealed));\n\n        revealTimeoutRef.current = setTimeout(revealNext, revealDelay);\n      } else {\n        // Animation complete\n        if (scrambleIntervalRef.current) {\n          clearInterval(scrambleIntervalRef.current);\n        }\n        setDisplayText(text);\n        setIsAnimating(false);\n        onComplete?.();\n      }\n    };\n\n    // Start with scrambled text, then begin revealing\n    setDisplayText(getScrambledText(0));\n    revealTimeoutRef.current = setTimeout(revealNext, revealDelay);\n  }, [\n    text,\n    scrambleSpeed,\n    revealDelay,\n    isAnimating,\n    trigger,\n    getScrambledText,\n    onComplete,\n  ]);\n\n  const reset = useCallback(() => {\n    if (scrambleIntervalRef.current) {\n      clearInterval(scrambleIntervalRef.current);\n    }\n    if (revealTimeoutRef.current) {\n      clearTimeout(revealTimeoutRef.current);\n    }\n    setDisplayText(text);\n    setIsAnimating(false);\n  }, [text]);\n\n  // Mount trigger\n  useEffect(() => {\n    if (trigger === 'mount' && !hasAnimated) {\n      animate();\n    }\n  }, [trigger, hasAnimated, animate]);\n\n  // Initialize display text for hover/scroll\n  useEffect(() => {\n    if (trigger === 'hover') {\n      setDisplayText(text);\n    }\n    if (trigger === 'scroll') {\n      setDisplayText(getScrambledText(0));\n    }\n  }, [text, trigger, getScrambledText]);\n\n  // Cleanup\n  useEffect(() => {\n    return () => {\n      if (scrambleIntervalRef.current) {\n        clearInterval(scrambleIntervalRef.current);\n      }\n      if (revealTimeoutRef.current) {\n        clearTimeout(revealTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  const handleMouseEnter = () => {\n    if (trigger === 'hover') {\n      setHasAnimated(false);\n      animate();\n    }\n  };\n\n  const handleMouseLeave = () => {\n    if (trigger === 'hover') {\n      reset();\n    }\n  };\n\n  return (\n    <motion.span\n      ref={containerRef}\n      className={`inline-block ${className}`}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      transition={{ duration: 0.2 }}\n    >\n      {displayText.split('').map((char, index) => (\n        <motion.span\n          key={`${index}-${char}`}\n          className=\"inline-block\"\n          style={{\n            whiteSpace: char === ' ' ? 'pre' : 'normal',\n          }}\n        >\n          {char}\n        </motion.span>\n      ))}\n    </motion.span>\n  );\n};\n\nexport default ShuffleText;\n",
      "path": "/components/ui/shuffle-text.tsx",
      "target": "components/ui/shuffle-text.tsx"
    }
  ],
  "categories": [
    "text-animation"
  ]
}