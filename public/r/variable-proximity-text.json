{
  "name": "variable-proximity-text",
  "description": "Interactive text where font weight changes based on mouse proximity to each letter.",
  "type": "registry:ui",
  "dependencies": [
    "framer-motion",
    "react"
  ],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:ui",
      "content": "'use client';\r\n\r\nimport { useRef, useEffect, useCallback, RefObject } from 'react';\r\n\r\ninterface VariableProximityTextProps {\r\n  label: string;\r\n  fromFontVariationSettings?: string;\r\n  toFontVariationSettings?: string;\r\n  containerRef: RefObject<HTMLElement | null>;\r\n  radius?: number;\r\n  falloff?: 'linear' | 'exponential' | 'gaussian';\r\n  className?: string;\r\n  style?: React.CSSProperties;\r\n}\r\n\r\nexport function VariableProximityText({\r\n  label,\r\n  fromFontVariationSettings = \"'wght' 400, 'opsz' 9\",\r\n  toFontVariationSettings = \"'wght' 900, 'opsz' 40\",\r\n  containerRef,\r\n  radius = 100,\r\n  falloff = 'linear',\r\n  className = '',\r\n  style,\r\n}: VariableProximityTextProps) {\r\n  const spanRef = useRef<HTMLSpanElement>(null);\r\n  const letterRefs = useRef<(HTMLSpanElement | null)[]>([]);\r\n  const mousePos = useRef({ x: -1000, y: -1000 });\r\n  const rafId = useRef<number>(0);\r\n\r\n  // Parse font variation settings\r\n  const parseSettings = useCallback((settingsStr: string) => {\r\n    const map = new Map<string, number>();\r\n    settingsStr.split(',').forEach((s) => {\r\n      const trimmed = s.trim();\r\n      const match = trimmed.match(/['\"]?(\\w+)['\"]?\\s+([\\d.]+)/);\r\n      if (match) {\r\n        map.set(match[1], parseFloat(match[2]));\r\n      }\r\n    });\r\n    return map;\r\n  }, []);\r\n\r\n  const fromSettings = parseSettings(fromFontVariationSettings);\r\n  const toSettings = parseSettings(toFontVariationSettings);\r\n\r\n  const calculateFalloff = useCallback(\r\n    (distance: number) => {\r\n      const norm = Math.min(Math.max(1 - distance / radius, 0), 1);\r\n      switch (falloff) {\r\n        case 'exponential':\r\n          return norm ** 2;\r\n        case 'gaussian':\r\n          return Math.exp(-((distance / (radius / 2)) ** 2) / 2);\r\n        case 'linear':\r\n        default:\r\n          return norm;\r\n      }\r\n    },\r\n    [radius, falloff],\r\n  );\r\n\r\n  const updateLetters = useCallback(() => {\r\n    if (!containerRef.current) return;\r\n\r\n    const containerRect = containerRef.current.getBoundingClientRect();\r\n\r\n    letterRefs.current.forEach((letterEl) => {\r\n      if (!letterEl) return;\r\n\r\n      const rect = letterEl.getBoundingClientRect();\r\n      const letterCenterX = rect.left + rect.width / 2 - containerRect.left;\r\n      const letterCenterY = rect.top + rect.height / 2 - containerRect.top;\r\n\r\n      const dx = mousePos.current.x - letterCenterX;\r\n      const dy = mousePos.current.y - letterCenterY;\r\n      const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n      if (distance >= radius) {\r\n        letterEl.style.fontVariationSettings = fromFontVariationSettings;\r\n      } else {\r\n        const falloffValue = calculateFalloff(distance);\r\n        const newSettings: string[] = [];\r\n\r\n        fromSettings.forEach((fromValue, axis) => {\r\n          const toValue = toSettings.get(axis) ?? fromValue;\r\n          const interpolated = fromValue + (toValue - fromValue) * falloffValue;\r\n          newSettings.push(`'${axis}' ${interpolated}`);\r\n        });\r\n\r\n        letterEl.style.fontVariationSettings = newSettings.join(', ');\r\n      }\r\n    });\r\n\r\n    rafId.current = requestAnimationFrame(updateLetters);\r\n  }, [\r\n    containerRef,\r\n    radius,\r\n    fromFontVariationSettings,\r\n    fromSettings,\r\n    toSettings,\r\n    calculateFalloff,\r\n  ]);\r\n\r\n  useEffect(() => {\r\n    const handleMouseMove = (e: MouseEvent) => {\r\n      if (!containerRef.current) return;\r\n      const rect = containerRef.current.getBoundingClientRect();\r\n      mousePos.current = {\r\n        x: e.clientX - rect.left,\r\n        y: e.clientY - rect.top,\r\n      };\r\n    };\r\n\r\n    const handleTouchMove = (e: TouchEvent) => {\r\n      if (!containerRef.current) return;\r\n      const rect = containerRef.current.getBoundingClientRect();\r\n      const touch = e.touches[0];\r\n      mousePos.current = {\r\n        x: touch.clientX - rect.left,\r\n        y: touch.clientY - rect.top,\r\n      };\r\n    };\r\n\r\n    const handleMouseLeave = () => {\r\n      mousePos.current = { x: -1000, y: -1000 };\r\n    };\r\n\r\n    window.addEventListener('mousemove', handleMouseMove);\r\n    window.addEventListener('touchmove', handleTouchMove);\r\n    containerRef.current?.addEventListener('mouseleave', handleMouseLeave);\r\n\r\n    // Start animation loop\r\n    rafId.current = requestAnimationFrame(updateLetters);\r\n\r\n    return () => {\r\n      window.removeEventListener('mousemove', handleMouseMove);\r\n      window.removeEventListener('touchmove', handleTouchMove);\r\n      containerRef.current?.removeEventListener('mouseleave', handleMouseLeave);\r\n      cancelAnimationFrame(rafId.current);\r\n    };\r\n  }, [containerRef, updateLetters]);\r\n\r\n  // Split into words and letters\r\n  const words = label.split(' ');\r\n  let globalIndex = 0;\r\n\r\n  return (\r\n    <span\r\n      ref={spanRef}\r\n      className={className}\r\n      style={{\r\n        display: 'inline',\r\n        fontFamily: \"'Roboto Flex', sans-serif\",\r\n        ...style,\r\n      }}\r\n    >\r\n      {words.map((word, wordIdx) => (\r\n        <span\r\n          key={wordIdx}\r\n          style={{ display: 'inline-block', whiteSpace: 'nowrap' }}\r\n        >\r\n          {word.split('').map((letter) => {\r\n            const idx = globalIndex++;\r\n            return (\r\n              <span\r\n                key={idx}\r\n                ref={(el) => {\r\n                  letterRefs.current[idx] = el;\r\n                }}\r\n                style={{\r\n                  display: 'inline-block',\r\n                  fontVariationSettings: fromFontVariationSettings,\r\n                }}\r\n              >\r\n                {letter}\r\n              </span>\r\n            );\r\n          })}\r\n          {wordIdx < words.length - 1 && (\r\n            <span style={{ display: 'inline-block' }}>&nbsp;</span>\r\n          )}\r\n        </span>\r\n      ))}\r\n    </span>\r\n  );\r\n}\r\n\r\nexport default VariableProximityText;\r\n",
      "path": "/components/ui/variable-proximity-text.tsx",
      "target": "components/ui/variable-proximity-text.tsx"
    }
  ],
  "categories": [
    "text-animation"
  ]
}