{
  "name": "text-type",
  "type": "registry:ui",
  "dependencies": [
    "react",
    "gsap"
  ],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:ui",
      "content": "'use client';\r\n\r\nimport { gsap } from 'gsap';\r\nimport {\r\n  createElement,\r\n  ElementType,\r\n  useCallback,\r\n  useEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n} from 'react';\r\n\r\ninterface TextTypeProps {\r\n  className?: string;\r\n  showCursor?: boolean;\r\n  hideCursorWhileTyping?: boolean;\r\n  cursorCharacter?: string | React.ReactNode;\r\n  cursorBlinkDuration?: number;\r\n  cursorClassName?: string;\r\n  text: string | string[];\r\n  as?: ElementType;\r\n  typingSpeed?: number;\r\n  initialDelay?: number;\r\n  pauseDuration?: number;\r\n  deletingSpeed?: number;\r\n  loop?: boolean;\r\n  textColors?: string[];\r\n  variableSpeed?: { min: number; max: number };\r\n  onSentenceComplete?: (sentence: string, index: number) => void;\r\n  startOnVisible?: boolean;\r\n  reverseMode?: boolean;\r\n}\r\n\r\nexport const TextType = ({\r\n  text,\r\n  as: Component = 'div',\r\n  typingSpeed = 50,\r\n  initialDelay = 0,\r\n  pauseDuration = 2000,\r\n  deletingSpeed = 30,\r\n  loop = true,\r\n  className = '',\r\n  showCursor = true,\r\n  hideCursorWhileTyping = false,\r\n  cursorCharacter = '|',\r\n  cursorClassName = '',\r\n  cursorBlinkDuration = 0.5,\r\n  textColors = [],\r\n  variableSpeed,\r\n  onSentenceComplete,\r\n  startOnVisible = false,\r\n  reverseMode = false,\r\n  ...props\r\n}: Readonly<TextTypeProps & React.HTMLAttributes<HTMLElement>>) => {\r\n  const [displayedText, setDisplayedText] = useState('');\r\n  const [currentCharIndex, setCurrentCharIndex] = useState(0);\r\n  const [isDeleting, setIsDeleting] = useState(false);\r\n  const [currentTextIndex, setCurrentTextIndex] = useState(0);\r\n  const [isVisible, setIsVisible] = useState(!startOnVisible);\r\n  const cursorRef = useRef<HTMLSpanElement>(null);\r\n  const containerRef = useRef<HTMLElement>(null);\r\n\r\n  const textArray = useMemo(\r\n    () => (Array.isArray(text) ? text : [text]),\r\n    [text],\r\n  );\r\n\r\n  const getRandomSpeed = useCallback(() => {\r\n    if (!variableSpeed) return typingSpeed;\r\n    const { min, max } = variableSpeed;\r\n    return Math.random() * (max - min) + min;\r\n  }, [variableSpeed, typingSpeed]);\r\n\r\n  const getCurrentTextColor = () => {\r\n    if (textColors.length === 0) return;\r\n    return textColors[currentTextIndex % textColors.length];\r\n  };\r\n\r\n  useEffect(() => {\r\n    if (!startOnVisible || !containerRef.current) return;\r\n\r\n    const observer = new IntersectionObserver(\r\n      (entries) => {\r\n        for (const entry of entries) {\r\n          if (entry.isIntersecting) {\r\n            setIsVisible(true);\r\n          }\r\n        }\r\n      },\r\n      { threshold: 0.1 },\r\n    );\r\n\r\n    observer.observe(containerRef.current);\r\n    return () => observer.disconnect();\r\n  }, [startOnVisible]);\r\n\r\n  useEffect(() => {\r\n    if (showCursor && cursorRef.current) {\r\n      gsap.set(cursorRef.current, { opacity: 1 });\r\n      gsap.to(cursorRef.current, {\r\n        opacity: 0,\r\n        duration: cursorBlinkDuration,\r\n        repeat: -1,\r\n        yoyo: true,\r\n        ease: 'power2.inOut',\r\n      });\r\n    }\r\n  }, [showCursor, cursorBlinkDuration]);\r\n\r\n  useEffect(() => {\r\n    if (!isVisible) return;\r\n\r\n    let timeout: NodeJS.Timeout;\r\n\r\n    const currentText = textArray[currentTextIndex];\r\n    const processedText = reverseMode\r\n      ? currentText.split('').reverse().join('')\r\n      : currentText;\r\n\r\n    const handleDeleting = () => {\r\n      if (displayedText === '') {\r\n        setIsDeleting(false);\r\n        if (currentTextIndex === textArray.length - 1 && !loop) {\r\n          return;\r\n        }\r\n\r\n        if (onSentenceComplete) {\r\n          onSentenceComplete(textArray[currentTextIndex], currentTextIndex);\r\n        }\r\n\r\n        setCurrentTextIndex((prev) => (prev + 1) % textArray.length);\r\n        setCurrentCharIndex(0);\r\n        timeout = setTimeout(() => {}, pauseDuration);\r\n      } else {\r\n        timeout = setTimeout(() => {\r\n          setDisplayedText((prev) => prev.slice(0, -1));\r\n        }, deletingSpeed);\r\n      }\r\n    };\r\n\r\n    const handleTyping = () => {\r\n      if (currentCharIndex < processedText.length) {\r\n        timeout = setTimeout(\r\n          () => {\r\n            setDisplayedText((prev) => prev + processedText[currentCharIndex]);\r\n            setCurrentCharIndex((prev) => prev + 1);\r\n          },\r\n          variableSpeed ? getRandomSpeed() : typingSpeed,\r\n        );\r\n      } else if (textArray.length > 1) {\r\n        timeout = setTimeout(() => {\r\n          setIsDeleting(true);\r\n        }, pauseDuration);\r\n      }\r\n    };\r\n\r\n    const executeTypingAnimation = () => {\r\n      if (isDeleting) {\r\n        handleDeleting();\r\n      } else {\r\n        handleTyping();\r\n      }\r\n    };\r\n\r\n    if (currentCharIndex === 0 && !isDeleting && displayedText === '') {\r\n      timeout = setTimeout(executeTypingAnimation, initialDelay);\r\n    } else {\r\n      executeTypingAnimation();\r\n    }\r\n\r\n    return () => clearTimeout(timeout);\r\n  }, [\r\n    currentCharIndex,\r\n    displayedText,\r\n    isDeleting,\r\n    typingSpeed,\r\n    deletingSpeed,\r\n    pauseDuration,\r\n    textArray,\r\n    currentTextIndex,\r\n    loop,\r\n    initialDelay,\r\n    isVisible,\r\n    reverseMode,\r\n    variableSpeed,\r\n    onSentenceComplete,\r\n    getRandomSpeed,\r\n  ]);\r\n\r\n  const shouldHideCursor =\r\n    hideCursorWhileTyping &&\r\n    (currentCharIndex < textArray[currentTextIndex].length || isDeleting);\r\n\r\n  return createElement(\r\n    Component,\r\n    {\r\n      ref: containerRef,\r\n      className: `inline-block whitespace-pre-wrap tracking-tight ${className}`,\r\n      ...props,\r\n    },\r\n    <span\r\n      className=\"text-foreground inline\"\r\n      style={{ color: getCurrentTextColor() || undefined }}\r\n    >\r\n      {displayedText}\r\n    </span>,\r\n    showCursor && (\r\n      <span\r\n        ref={cursorRef}\r\n        className={`text-primary ml-1 inline-block opacity-100 ${\r\n          shouldHideCursor ? 'hidden' : ''\r\n        } ${cursorClassName}`}\r\n      >\r\n        {cursorCharacter}\r\n      </span>\r\n    ),\r\n  );\r\n};",
      "path": "/./components/ui/text-type.tsx",
      "target": "components/ui/text-type.tsx"
    }
  ]
}